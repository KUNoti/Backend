// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: finder_event.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const finderEvent = `-- name: FinderEvent :many
SELECT id, start_date, end_date, created_at, updated_at, title, latitude, longitude, price, rating, image, creator, detail, location_name, need_regis
FROM events
WHERE
    (id = $1 OR $1 IS NULL)
  AND (title = $2 OR $2 IS NULL)
  AND (price = $3 OR $3 IS NULL)
  AND (creator = $4 OR $4 IS NULL)
  AND (location_name = $5 OR $5 IS NULL)
  AND (need_regis = $6 OR $6 IS NULL)
  AND ((start_date >= $7 AND end_date <= $8)
    OR ($7 IS NULL AND $8 IS NULL))
ORDER BY id DESC
`

type FinderEventParams struct {
	ID           pgtype.Int4      `json:"id"`
	Title        pgtype.Text      `json:"title"`
	Price        pgtype.Float8    `json:"price"`
	Creator      pgtype.Text      `json:"creator"`
	LocationName pgtype.Text      `json:"location_name"`
	NeedRegis    pgtype.Bool      `json:"need_regis"`
	StartDate    pgtype.Timestamp `json:"start_date"`
	EndDate      pgtype.Timestamp `json:"end_date"`
}

// AND (start_date = sqlc.narg('start_date') OR sqlc.narg('start_date') IS NULL)
// AND (end_date = sqlc.narg('end_date') OR sqlc.narg('end_date') IS NULL)
func (q *Queries) FinderEvent(ctx context.Context, arg FinderEventParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, finderEvent,
		arg.ID,
		arg.Title,
		arg.Price,
		arg.Creator,
		arg.LocationName,
		arg.NeedRegis,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Latitude,
			&i.Longitude,
			&i.Price,
			&i.Rating,
			&i.Image,
			&i.Creator,
			&i.Detail,
			&i.LocationName,
			&i.NeedRegis,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
